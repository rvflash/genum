// Copyright (c) 2021 Herv√© Gouchet. All rights reserved.
// Use of this source code is governed by the MIT License
// that can be found in the LICENSE file.

package genum

import (
	"encoding/csv"
	"errors"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"strings"
)

// Configurator must be implemented by any methods acted as an enum layout generator.
type Configurator func(g *Generator) error

// ParseEnums reads the given source as a CSV and tries to create a list of constants based on it.
func ParseEnums(data io.Reader, enumType string, enumKind Kind, joinPrefix, trimPrefix, useIota bool) Configurator {
	return func(g *Generator) error {
		var (
			curIota           int64 = -1
			curUint, prevUint uint64
			curSign, prevSign bool
		)
		r := csv.NewReader(data)
		r.FieldsPerRecord = -1 // Records may have a variable number of fields.
		g.enums = make([]Enum, 0)
		for {
			d, err := r.Read()
			if err != nil {
				if errors.Is(err, io.EOF) {
					break
				}
				return fmt.Errorf("source file: %w", err)
			}
			e := Enum{
				Type: enumType,
				Kind: enumKind,
				Text: enumName(d, enumType, joinPrefix, trimPrefix),
			}
			if useIota {
				curIota++
			}
			e.RawText, _ = field(d, namePos)
			e.Value, e.Iota, curUint, curSign = enumValue(d, enumKind, curIota, prevUint, prevSign)
			g.basic = enumKind.IsInteger() && absDiff(curUint, curSign, prevUint, prevSign) == 1
			g.enums = append(g.enums, e)
			prevUint, prevSign = curUint, curSign
		}
		if len(g.enums) == 0 {
			return fmt.Errorf("source file: %w", io.ErrUnexpectedEOF)
		}
		return nil
	}
}

// PrintEnums prints the list of constants.
func PrintEnums(enumType string, enumKind Kind, useIota, commented bool) Configurator {
	return func(g *Generator) error {
		if enumType == "" {
			return fmt.Errorf("enum type: %w", ErrMissing)
		}
		g.printf("\n")
		g.printf("// %s is an enum.\n", enumType)
		g.printf("type %s %s\n", enumType, enumKind.Name())
		g.printf("\n")
		g.printf("// List of known %s enums.\n", enumType)
		g.printf("const (\n")
		for k, v := range g.enums {
			g.printf(v.Format(k, useIota, commented))
		}
		g.printf(")\n")

		return nil
	}
}

// PrintHeader prints the go file header (package, import, etc.).
func PrintHeader(pkg string, args []string, packages map[string]struct{}) Configurator {
	return func(g *Generator) error {
		if pkg == "" {
			return fmt.Errorf("package RawName: %w", ErrMissing)
		}
		g.printf("// Code generated by %q; DO NOT EDIT.\n", Command+" "+strings.Join(args, " "))
		g.printf("\n")
		g.printf("package %s\n", pkg)
		g.printf("\n")
		if len(packages) == 0 {
			return nil
		}
		g.printf("import (\n")
		for name := range packages {
			g.printf("%q\n", name)
		}
		g.printf(")\n")

		return nil
	}
}

// PrintJSONMarshaler adds methods to marshal and unmarshal the enum value as JSON data.
func PrintJSONMarshaler(enumType string, enumKind Kind) Configurator {
	return func(g *Generator) error {
		// json.Marshaler
		g.printf("\n")
		g.printf("// MarshalJSON implements the json.Marshaler interface.\n")
		g.printf("func (e %s) MarshalJSON() ([]byte, error) {\n", enumType)
		g.printf("return json.Marshal(%s)", strConvFormat(enumKind))
		g.printf("}\n")

		// json.Unmarshaler
		g.printf("// UnmarshalJSON implements the json.Unmarshaler interface.\n")
		g.printf("func (e *%s) UnmarshalJSON(data []byte) error{\n", enumType)
		g.printf("var (\n")
		g.printf("s string\n")
		g.printf("err = json.Unmarshal(data, &s)\n")
		g.printf(")\n")
		g.printf("if err != nil {\n")
		g.printf(returnErr, enumType, enumKind.Name(), srcName)
		g.printf("}\n")
		g.printf(strConvParse(enumType, enumKind))
		g.printf("return nil\n")
		g.printf("}\n")

		return nil
	}
}

// PrintStringer chooses the "best" methods regarding the data to manage the String method.
func PrintStringer(format string, enumType string, enumKind Kind) Configurator {
	return func(g *Generator) error {
		switch g.mode() {
		case basic:
			return g.basicString(format, enumType, enumKind)
		case average:
			return g.averageString(format, enumType, enumKind)
		default:
			return g.advanceString(format, enumType, enumKind)
		}
	}
}

// PrintTextMarshaler adds methods to marshal and unmarshal the enum String value as a text.
func PrintTextMarshaler(format string, enumType string) Configurator {
	return func(g *Generator) error {
		// encoding.TextMarshaler
		g.printf("\n")
		g.printf("// MarshalText implements the encoding.TextMarshaler interface.\n")
		g.printf("func (e %s) MarshalText() (text []byte, err error) {\n", enumType)
		g.printf("return []byte(e.String()), nil")
		g.printf("}\n")

		// encoding.TextUnmarshaler
		g.printf("var _%sStrings = map[string]%s{\n", enumType, enumType)
		var (
			v   interface{}
			err error
		)
		for k, e := range g.enums {
			if format != NameFormat() {
				v, err = e.ParseValue()
				if err != nil {
					return fmt.Errorf("enum value #%d: %w", k, err)
				}
				g.printf("%q: %s,\n", fmt.Sprintf(format, e.RawText, v, enumType), e.Text)
			} else {
				g.printf("%q: %s,\n", e.RawText, e.Text)
			}
		}
		g.printf("}\n")
		// encoding.TextUnmarshaler
		g.printf("\n")
		g.printf("// UnmarshalText implements the encoding.TextUnmarshaler interface.\n")
		g.printf("func (e *%s) UnmarshalText(text []byte) error{\n", enumType)
		g.printf("%s2, ok := _%sStrings[string(text)]\n", shortName, enumType)
		g.printf("if !ok {\n")
		g.printf("return fmt.Errorf(\"%%q is not a known %s\", text)\n", enumType)
		g.printf("}\n")
		g.printf("*%s = %s2\n", shortName, shortName)
		g.printf("return nil\n")
		g.printf("}\n")

		return nil
	}
}

// PrintXMLMarshaler adds methods to marshal and unmarshal the enum value as XML data.
func PrintXMLMarshaler(enumType string, enumKind Kind) Configurator {
	return func(g *Generator) error {
		// json.Marshaler
		g.printf("\n")
		g.printf("// MarshalXML implements the xml.Marshaler interface.\n")
		g.printf("func (e %s) MarshalXML(x *xml.Encoder, start xml.StartElement) error {\n", enumType)
		g.printf("return x.EncodeElement(%s, start)", strConvFormat(enumKind))
		g.printf("}\n")

		// json.Unmarshaler
		g.printf("// UnmarshalXML implements the xml.Unmarshaler interface.\n")
		g.printf("func (e *%s) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error{\n", enumType)
		g.printf("var (\n")
		g.printf("s string\n")
		g.printf("err = d.DecodeElement(&s, &start)\n")
		g.printf(")\n")
		g.printf("if err != nil {\n")
		g.printf(returnErr, enumType, enumKind.Name(), strName)
		g.printf("}\n")
		g.printf(strConvParse(enumType, enumKind))
		g.printf("return nil\n")
		g.printf("}\n")

		return nil
	}
}

// WriteFile tries to write the go file.
func WriteFile(filename string) Configurator {
	return func(g *Generator) error {
		if filename == "" {
			return fmt.Errorf("destination filename: %w", ErrMissing)
		}
		if g.err != nil {
			return g.err
		}
		src, err := format.Source(g.buf.Bytes())
		if err != nil {
			// Allows the user to compile the output to see the error.
			src = g.buf.Bytes()
		}
		wrr := ioutil.WriteFile(filename, src, 0600)
		if wrr != nil {
			return fmt.Errorf("destination: %w", wrr)
		}
		if err != nil {
			return fmt.Errorf("go format failed: %w", wrr)
		}
		return nil
	}
}
